# internship_application_greedy_dynamic
# Task
A programmer has an upcoming exam and only has N hours left to prepare. The textbook has M topics, each of which requires a certain amount of hours Ti for studying, and has a certain number of questions Ki that could potentially appear on the exam. Unfortunately,N hours is not enough time to completely study all the topics, but the exam task will have L questions, chosen randomly from all the questions in the textbook with an equal probability. What is the best way to use limited time to maximize the chances of getting the best possible grade?
# The 2 solutions
### greedy approach 
The greedy algorithm used in this problem involves sorting the topics by their efficiency (i.e., the number of questions per hour of study time), and then studying each topic in order of decreasing efficiency until we run out of time. If we have enough time to study a whole topic, we do so and add all its questions to our total. Otherwise, we study the topic partially, proportional to the amount of time we have left and the topic's efficiency. The algorithm returns the total number of questions studied in the given time using the greedy approach.

The time complexity of the greedy algorithm is O(m log m), where m is the number of topics. This is because the algorithm involves sorting the topics by their efficiency, which requires O(m log m) time using a comparison-based sorting algorithm such as quicksort or mergesort. The subsequent loop over the sorted topics takes O(m) time, so the overall time complexity is O(m log m + m) = O(m log m). The space complexity of the algorithm is O(m), which is the space required to store the array of topic indices.

The greedy algorithm used in this problem is not guaranteed to produce an optimal solution in all cases, as it may overlook certain combinations of topics and study times that could lead to a better solution. However, in many cases, the greedy algorithm can produce a good approximation of the optimal solution with much less computational effort than other algorithms such as dynamic programming. Overall, the greedy algorithm is a useful tool for solving optimization problems quickly and efficiently when an exact solution is not required.
### Dynamic Programming approach
The dynamic programming approach used in this problem involves creating a 2D dynamic programming array dp, where dp[i][j] represents the maximum number of questions that can be answered by studying topics 1 to i within j hours. We fill in this array using nested loops that iterate over the topics and study times. In each iteration, we check whether we have enough time to study the current topic. If not, we skip the topic and set the maximum number of questions to the maximum number of questions that can be answered by studying topics 1 to i-1 within j hours. If we do have enough time, we choose between two options: not studying the current topic and taking the maximum number of questions that can be answered by studying topics 1 to i-1 within j hours, or studying the current topic and taking the maximum number of questions that can be answered by studying topics 1 to i-1 within j-t[i-1] hours, plus the number of questions that can be answered by studying the current topic. The algorithm returns the maximum number of questions that can be answered by studying topics 1 to m within n hours.

The time complexity of the dynamic programming algorithm is O(mn), where m is the number of topics and n is the available study time. This is because the algorithm involves filling in a 2D array of size (m+1) x (n+1), which takes O(mn) time. The space complexity of the algorithm is also O(mn), which is the space required to store the 2D array.

The dynamic programming approach used in this problem guarantees to produce the optimal solution by systematically breaking down the problem into smaller subproblems and solving each subproblem once to avoid redundant calculations. This makes the dynamic programming approach more reliable and versatile than the greedy algorithm, especially for larger problem sizes or when the study time available is much larger than the number of topics. However, the dynamic programming approach can be slower and less efficient than the greedy algorithm for small problem sizes or when the number of topics is small relative to the study time available. Overall, the dynamic programming approach is a powerful tool for solving complex optimization problems that require an exact solution.